<ShowPlanXML xmlns="http://schemas.microsoft.com/sqlserver/2004/07/showplan" Version="1.0" Build="9.00.4035.00"><BatchSequence><Batch><Statements><StmtSimple StatementText="CREATE PROCEDURE proc_reFolderTree&#xd;&#xa;&#x9;@Tree_ID Int&#xd;&#xa;AS&#xd;&#xa;&#x9;SET NOCOUNT ON&#xd;&#xa;&#x9;DECLARE @RC Int&#xd;&#xa;&#x9;DECLARE @counter Int&#xd;&#xa;&#x9;DECLARE @max_counter Int&#xd;&#xa;&#x9;DECLARE @current_level Int&#xd;&#xa;&#x9;DECLARE @Prj_Name VarChar(254)&#xd;&#xa;&#x9;DECLARE @Tree TABLE (&#xd;&#xa;&#x9;&#x9;Prj_ID float NOT NULL, &#xd;&#xa;&#x9;&#x9;PRJ_PID float NULL)&#xd;&#xa;&#xd;&#xa;&#x9;DECLARE @Stack TABLE (&#xd;&#xa;&#x9;&#x9;Prj_ID float NOT NULL,&#xd;&#xa;&#x9;&#x9;Left_Visit int NULL,&#xd;&#xa;&#x9;&#x9;Right_Visit int NULL,&#xd;&#xa;&#x9;&#x9;StackLevel int NULL)&#xd;&#xa;&#x9;&#xd;&#xa;&#x9;IF NOT EXISTS(SELECT * FROM MHGroup.Projects WHERE Prj_ID = @Tree_ID AND Tree_ID = @Tree_ID)&#xd;&#xa;&#x9;&#x9;BEGIN&#xd;&#xa;&#x9;&#x9;RAISERROR(&apos;No root folder found for Tree_ID %d!  Exiting...&apos;, 16, 1, @Tree_ID)&#xd;&#xa;&#x9;&#x9;GOTO proc_error&#xd;&#xa;&#x9;&#x9;END&#xd;&#xa;&#x9;&#x9;&#xd;&#xa;&#x9;SELECT @Prj_Name = Prj_Name FROM MHGroup.Projects WHERE Prj_ID = @Tree_ID&#xd;&#xa;&#x9;RAISERROR(&apos;Recalculating left_visit and right_visit for tree %s (Tree_ID %d)&apos;, 10, 1, @Prj_Name, @Tree_ID)&#xd;&#xa;&#xd;&#xa;&#x9;-- Fill the @Tree table with all projects in the tree&#xd;&#xa;&#x9;INSERT INTO @TREE(Prj_ID, PRJ_PID)&#xd;&#xa;&#x9;&#x9;SELECT Prj_ID, PRJ_PID&#xd;&#xa;&#x9;&#x9;FROM MHGROUP.PROJECTS WHERE TREE_ID = @Tree_ID&#xd;&#xa;&#x9;SELECT @counter = 2, @max_counter = 2 * @@ROWCOUNT, @current_level = 1&#xd;&#xa;&#x9;-- @max_count = 2 x the count of rows because we visit every row twice - once to see how many subnodes and once to update it with lv/rv&#xd;&#xa;&#xd;&#xa;&#x9;-- Put the root entry in @Stack&#xd;&#xa;&#x9;INSERT INTO @Stack(StackLevel, Prj_ID, Left_Visit, Right_Visit)&#xd;&#xa;&#x9;&#x9;SELECT @current_level, Prj_ID, 1, NULL FROM @Tree WHERE Prj_ID = @Tree_ID&#xd;&#xa;&#xd;&#xa;&#x9;-- And remove it from @Tree&#xd;&#xa;&#x9;DELETE FROM @Tree&#xd;&#xa;&#x9;&#x9;WHERE Prj_ID = @Tree_ID&#xd;&#xa;&#xd;&#xa;&#x9;WHILE @counter &lt;= (@max_counter)&#xd;&#xa;&#x9;&#x9;BEGIN&#xd;&#xa;&#x9;&#x9;--RAISERROR(&apos;Level %d, @Stack: &apos;, 10, 1, @current_level)&#xd;&#xa;&#x9;&#x9;--SELECT * FROM @Stack&#xd;&#xa;&#x9;&#x9;--RAISERROR(&apos;Level %d, @Tree: &apos;, 10, 1, @current_level)&#xd;&#xa;&#x9;&#x9;--SELECT * FROM @Tree&#xd;&#xa;&#xd;&#xa;&#x9;&#x9;IF EXISTS (SELECT * FROM @Stack s JOIN @Tree t ON s.Prj_ID = t.PRJ_PID WHERE s.StackLevel = @current_level) -- get children below current &quot;top&quot; node&#xd;&#xa;&#x9;&#x9;&#x9;BEGIN &#xd;&#xa;&#x9;&#x9;&#x9;INSERT INTO @Stack(StackLevel, Prj_ID, Left_Visit, Right_Visit)&#xd;&#xa;&#x9;&#x9;&#x9;&#x9;SELECT @current_level + 1, MAX(t.Prj_ID), @counter, NULL&#xd;&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;FROM @Stack s JOIN @Tree t&#xd;&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;&#x9;ON s.Prj_ID = t.PRJ_PID&#xd;&#xa;&#x9;&#x9;&#x9;&#x9;&#x9;WHERE s.StackLevel = @current_level&#xd;&#xa;&#x9;&#x9;&#x9;--RAISERROR(&apos;Has children - current_level %d, counter %d...&apos;, 10, 1, @current_level, @counter)&#x9;&#x9;&#xd;&#xa;&#x9;&#x9;&#x9;DELETE @Tree WHERE Prj_ID = (SELECT Prj_ID FROM @Stack WHERE StackLevel = @current_level + 1)&#xd;&#xa;&#x9;&#x9;&#x9;SELECT @counter = @counter + 1, @current_level = @current_level + 1&#xd;&#xa;&#x9;&#x9;&#x9;END&#xd;&#xa;&#x9;&#x9;ELSE -- else there are no subfolders so we update the stack with r/l values&#xd;&#xa;&#x9;&#x9;&#x9;BEGIN&#xd;&#xa;&#x9;&#x9;&#x9;UPDATE @Stack -- the StackLevel field is also used to track the node we&apos;re working on.  Since we&apos;re done with this node, set it negative&#xd;&#xa;&#x9;&#x9;&#x9;&#x9;SET Right_Visit = @counter, StackLevel = -StackLevel &#xd;&#xa;&#x9;&#x9;&#x9;&#x9;WHERE StackLevel = @current_level&#xd;&#xa;&#x9;&#x9;&#x9;--RAISERROR(&apos;No children - right visit/counter set to %d, current_level is %d&apos;, 10, 1, @counter, @current_level)&#xd;&#xa;&#x9;&#x9;&#x9;-- Update counter and set current level to go back up one level because there&apos;s nothing below the current node&#xd;&#xa;&#x9;&#x9;&#x9;SELECT @counter = @counter + 1, @current_level = @current_level - 1&#xd;&#xa;&#x9;&#x9;&#x9;END&#xd;&#xa;&#x9;&#x9;END&#xd;&#xa;&#xd;&#xa;&#x9;-- Update the actual Projects table&#xd;&#xa;&#x9;UPDATE MHGROUP.PROJECTS&#xd;&#xa;&#x9;&#x9;SET Left_Visit = b.Left_Visit, Right_Visit = b.Right_Visit&#xd;&#xa;&#x9;FROM MHGROUP.PROJECTS a JOIN @Stack b&#xd;&#xa;&#x9;&#x9;ON a.Prj_ID = b.Prj_ID&#xd;&#xa;&#xd;&#xa;" StatementId="1" StatementCompId="55" StatementType="UPDATE" StatementSubTreeCost="0.140146" StatementEstRows="1" StatementOptmLevel="FULL" StatementOptmEarlyAbortReason="GoodEnoughPlanFound"><QueryPlan CachedPlanSize="52" CompileTime="101" CompileCPU="19" CompileMemory="352"><RelOp NodeId="0" PhysicalOp="Clustered Index Update" LogicalOp="Update" EstimateRows="1" EstimateIO="0.11" EstimateCPU="1.1e-005" AvgRowSize="9" EstimatedTotalSubtreeCost="0.140146" Parallel="0" EstimateRebinds="0" EstimateRewinds="0"><OutputList/><Update><Object Database="[PERSQ]" Schema="[MHGROUP]" Table="[PROJECTS]" Index="[IX_PROJCTS_TREE_ID]"/><Object Database="[PERSQ]" Schema="[MHGROUP]" Table="[PROJECTS]" Index="[PK_PROJECTS]"/><Object Database="[PERSQ]" Schema="[MHGROUP]" Table="[PROJECTS]" Index="[UX_PROJCTS_PRJ_ID]"/><Object Database="[PERSQ]" Schema="[MHGROUP]" Table="[PROJECTS]" Index="[IX_PROJCTS_TYPE]"/><Object Database="[PERSQ]" Schema="[MHGROUP]" Table="[PROJECTS]" Index="[IX_PROJCTS_DOCNUM]"/><Object Database="[PERSQ]" Schema="[MHGROUP]" Table="[PROJECTS]" Index="[IX_PROJCTS_PRJ_PID]"/><Object Database="[PERSQ]" Schema="[MHGROUP]" Table="[PROJECTS]" Index="[IX_PROJCTS_EML]"/><Object Database="[PERSQ]" Schema="[MHGROUP]" Table="[PROJECTS]" Index="[IX_PRJCTS_OWNR_TYP]"/><Object Database="[PERSQ]" Schema="[MHGROUP]" Table="[PROJECTS]" Index="[IX_PROJCTS_DOCSS]"/><Object Database="[PERSQ]" Schema="[MHGROUP]" Table="[PROJECTS]" Index="[IX_PROJCTS_PRJSS]"/><Object Database="[PERSQ]" Schema="[MHGROUP]" Table="[PROJECTS]" Index="[IX_PROJCTS_OWNER]"/><SetPredicate><ScalarOperator ScalarString="[PERSQ].[MHGROUP].[PROJECTS].[LEFT_VISIT] = @Stack.[Left_Visit] as [b].[Left_Visit],[PERSQ].[MHGROUP].[PROJECTS].[RIGHT_VISIT] = @Stack.[Right_Visit] as [b].[Right_Visit]"><ScalarExpressionList><ScalarOperator><MultipleAssign><Assign><ColumnReference Database="[PERSQ]" Schema="[MHGROUP]" Table="[PROJECTS]" Column="LEFT_VISIT"/><ScalarOperator><Identifier><ColumnReference Table="@Stack" Alias="[b]" Column="Left_Visit"/></Identifier></ScalarOperator></Assign><Assign><ColumnReference Database="[PERSQ]" Schema="[MHGROUP]" Table="[PROJECTS]" Column="RIGHT_VISIT"/><ScalarOperator><Identifier><ColumnReference Table="@Stack" Alias="[b]" Column="Right_Visit"/></Identifier></ScalarOperator></Assign></MultipleAssign></ScalarOperator></ScalarExpressionList></ScalarOperator></SetPredicate><RelOp NodeId="1" PhysicalOp="Top" LogicalOp="Top" EstimateRows="1" EstimateIO="0" EstimateCPU="1e-007" AvgRowSize="31" EstimatedTotalSubtreeCost="0.0301354" Parallel="0" EstimateRebinds="0" EstimateRewinds="0"><OutputList><ColumnReference Column="Uniq1002"/><ColumnReference Database="[PERSQ]" Schema="[MHGROUP]" Table="[PROJECTS]" Alias="[a]" Column="LEFT_VISIT"/><ColumnReference Database="[PERSQ]" Schema="[MHGROUP]" Table="[PROJECTS]" Alias="[a]" Column="RIGHT_VISIT"/><ColumnReference Database="[PERSQ]" Schema="[MHGROUP]" Table="[PROJECTS]" Alias="[a]" Column="TREE_ID"/><ColumnReference Table="@Stack" Alias="[b]" Column="Left_Visit"/><ColumnReference Table="@Stack" Alias="[b]" Column="Right_Visit"/></OutputList><Top RowCount="1" IsPercent="0" WithTies="0"><TopExpression><ScalarOperator ScalarString="(0)"><Const ConstValue="(0)"/></ScalarOperator></TopExpression><RelOp NodeId="3" PhysicalOp="Nested Loops" LogicalOp="Inner Join" EstimateRows="10" EstimateIO="0" EstimateCPU="4.18e-005" AvgRowSize="31" EstimatedTotalSubtreeCost="0.0301353" Parallel="0" EstimateRebinds="0" EstimateRewinds="0"><OutputList><ColumnReference Column="Uniq1002"/><ColumnReference Database="[PERSQ]" Schema="[MHGROUP]" Table="[PROJECTS]" Alias="[a]" Column="LEFT_VISIT"/><ColumnReference Database="[PERSQ]" Schema="[MHGROUP]" Table="[PROJECTS]" Alias="[a]" Column="RIGHT_VISIT"/><ColumnReference Database="[PERSQ]" Schema="[MHGROUP]" Table="[PROJECTS]" Alias="[a]" Column="TREE_ID"/><ColumnReference Table="@Stack" Alias="[b]" Column="Left_Visit"/><ColumnReference Table="@Stack" Alias="[b]" Column="Right_Visit"/></OutputList><NestedLoops Optimized="0"><OuterReferences><ColumnReference Table="@Stack" Alias="[b]" Column="Prj_ID"/></OuterReferences><RelOp NodeId="4" PhysicalOp="Sort" LogicalOp="Distinct Sort" EstimateRows="10" EstimateIO="0.0112613" EstimateCPU="0.000400713" AvgRowSize="23" EstimatedTotalSubtreeCost="0.0149847" Parallel="0" EstimateRebinds="0" EstimateRewinds="0"><OutputList><ColumnReference Table="@Stack" Alias="[b]" Column="Prj_ID"/><ColumnReference Table="@Stack" Alias="[b]" Column="Left_Visit"/><ColumnReference Table="@Stack" Alias="[b]" Column="Right_Visit"/></OutputList><MemoryFractions Input="1" Output="1"/><Sort Distinct="1"><OrderBy><OrderByColumn Ascending="1"><ColumnReference Table="@Stack" Alias="[b]" Column="Prj_ID"/></OrderByColumn></OrderBy><RelOp NodeId="5" PhysicalOp="Table Scan" LogicalOp="Table Scan" EstimateRows="37" EstimateIO="0.003125" EstimateCPU="0.0001977" AvgRowSize="23" EstimatedTotalSubtreeCost="0.0033227" Parallel="0" EstimateRebinds="0" EstimateRewinds="0"><OutputList><ColumnReference Table="@Stack" Alias="[b]" Column="Prj_ID"/><ColumnReference Table="@Stack" Alias="[b]" Column="Left_Visit"/><ColumnReference Table="@Stack" Alias="[b]" Column="Right_Visit"/></OutputList><TableScan Ordered="0" ForcedIndex="0" NoExpandHint="0"><DefinedValues><DefinedValue><ColumnReference Table="@Stack" Alias="[b]" Column="Prj_ID"/></DefinedValue><DefinedValue><ColumnReference Table="@Stack" Alias="[b]" Column="Left_Visit"/></DefinedValue><DefinedValue><ColumnReference Table="@Stack" Alias="[b]" Column="Right_Visit"/></DefinedValue></DefinedValues><Object Table="[@Stack]" Alias="[b]"/></TableScan></RelOp></Sort></RelOp><RelOp NodeId="6" PhysicalOp="Index Seek" LogicalOp="Index Seek" EstimateRows="1" EstimateIO="0.003125" EstimateCPU="0.0001581" AvgRowSize="23" EstimatedTotalSubtreeCost="0.0151088" Parallel="0" EstimateRebinds="9" EstimateRewinds="0"><OutputList><ColumnReference Column="Uniq1002"/><ColumnReference Database="[PERSQ]" Schema="[MHGROUP]" Table="[PROJECTS]" Alias="[a]" Column="LEFT_VISIT"/><ColumnReference Database="[PERSQ]" Schema="[MHGROUP]" Table="[PROJECTS]" Alias="[a]" Column="RIGHT_VISIT"/><ColumnReference Database="[PERSQ]" Schema="[MHGROUP]" Table="[PROJECTS]" Alias="[a]" Column="TREE_ID"/></OutputList><IndexScan Ordered="1" ScanDirection="FORWARD" ForcedIndex="0" NoExpandHint="0"><DefinedValues><DefinedValue><ColumnReference Column="Uniq1002"/></DefinedValue><DefinedValue><ColumnReference Database="[PERSQ]" Schema="[MHGROUP]" Table="[PROJECTS]" Alias="[a]" Column="LEFT_VISIT"/></DefinedValue><DefinedValue><ColumnReference Database="[PERSQ]" Schema="[MHGROUP]" Table="[PROJECTS]" Alias="[a]" Column="RIGHT_VISIT"/></DefinedValue><DefinedValue><ColumnReference Database="[PERSQ]" Schema="[MHGROUP]" Table="[PROJECTS]" Alias="[a]" Column="TREE_ID"/></DefinedValue></DefinedValues><Object Database="[PERSQ]" Schema="[MHGROUP]" Table="[PROJECTS]" Index="[PK_PROJECTS]" Alias="[a]"/><SeekPredicates><SeekPredicate><Prefix ScanType="EQ"><RangeColumns><ColumnReference Database="[PERSQ]" Schema="[MHGROUP]" Table="[PROJECTS]" Alias="[a]" Column="PRJ_ID"/></RangeColumns><RangeExpressions><ScalarOperator ScalarString="@Stack.[Prj_ID] as [b].[Prj_ID]"><Identifier><ColumnReference Table="@Stack" Alias="[b]" Column="Prj_ID"/></Identifier></ScalarOperator></RangeExpressions></Prefix></SeekPredicate></SeekPredicates></IndexScan></RelOp></NestedLoops></RelOp></Top></RelOp></Update></RelOp></QueryPlan></StmtSimple></Statements></Batch></BatchSequence></ShowPlanXML>
